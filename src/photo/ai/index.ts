/* eslint-disable max-len */

import { Tags } from '@/tag';
import { parseCommaSeparatedKeyString } from '@/utility/key';
import { z } from 'zod';

export type AiAutoGeneratedField =
  'title' |
  'caption' |
  'tags' |
  'semantic'

export const AI_AUTO_GENERATED_FIELDS_ALL: AiAutoGeneratedField[] = [
  'title',
  'caption',
  'tags',
  'semantic',
];

export const AI_AUTO_GENERATED_FIELDS_DEFAULT: AiAutoGeneratedField[] = [
  'title',
  'tags',
  'semantic',
];

export const parseAiAutoGeneratedFieldsString = (
  string?: string,
) =>
  parseCommaSeparatedKeyString({
    string,
    acceptedKeys: AI_AUTO_GENERATED_FIELDS_ALL,
    defaultKeys: AI_AUTO_GENERATED_FIELDS_DEFAULT,
  });

export const getAiTextFieldsToGenerate = (
  textFieldsToGenerate: AiAutoGeneratedField[],
  excludeTitle?: boolean,
  excludeCaption?: boolean,
  excludeTags?: boolean,
  excludeSemantic?: boolean,
): AiAutoGeneratedField[] => {
  return textFieldsToGenerate.filter(field =>
    !(excludeTitle && field === 'title') &&
    !(excludeCaption && field === 'caption') &&
    !(excludeTags && field === 'tags') &&
    !(excludeSemantic && field === 'semantic'),
  );
};

export type AiImageQuery =
  'title' |
  'caption' |
  'title-and-caption' |
  'tags' |
  'semantic';

export const getAiImageQuery = (
  query: AiImageQuery,
  existingTitle?: string,
  existingTags: Tags = [],
): string => {
  switch (query) {
  case 'title': return 'As a photography curator, create a concise and evocative bilingual title that captures the essence of this image. Focus on the mood, key subject, or distinctive element that makes this photo memorable. Avoid generic words like "moment," "beauty," or "scene." Keep it within 3-5 words per language and make it specific to what you see. Format: "English Title | 中文标题". This is to generate titles for a photo, not to identify specific people in the image.';
  case 'caption': return 'As a photography curator with an eye for authenticity, craft a bilingual caption that reveals the true character of this scene. Focus on the distinctive visual qualities that make this moment special - the interplay of light, the mood of the colors, the texture of the environment, or the atmosphere of the moment. Avoid technical jargon and clichéd descriptions. Keep each caption within 10 words but make them meaningful. Format: "English Caption | 中文说明". If the caption could describe any similar photo, start over. This is to generate captions for a photo, not to identify specific people in the image.';
  case 'title-and-caption': return 'You are a creative bilingual photography curator who values authenticity. First, create a meaningful title that avoids both clichés (no "echoes", "whispers", "dreams", "soul") and technical jargon. Focus on the genuine mood, atmosphere, and key elements that make this image unique. Draw from the actual feeling, time, place, or natural elements present. Then write a complementary caption that deepens this authentic perspective. Format: Title: "English Title | 中文标题" Caption: "English Caption | 中文说明". Keep titles within 5-6 words and captions within 8 words per language. If either could apply to any photo, start over. This is to generate title and captions for a photo, not to identify specific people in the image.';
  case 'tags': {
    const tagQuery = `First, identify which ONE genre best describes this image from ONLY these options: portrait photography, landscape photography, animal photography, street photography, event photography, wedding photography.

Then generate exactly 2 tags as a comma-separated list in this format: "genre tag, thematic tag"

Requirements:
- First tag: The genre you identified (exactly as listed above)
- Second tag: A thematic category that could apply to multiple similar photos. Think of it as a sub-category or common theme that photographers would use to organize their work
- The second tag should be specific enough to be meaningful but general enough to group 10-50 similar photos
- Avoid overly specific details that would only apply to this one photo
- Output format: "tag1, tag2" (comma-separated, no numbering)

Good thematic tags examples:
- "portrait photography, environmental portrait" (not "woman in red dress by window")
- "street photography, urban nightlife" (not "tokyo neon sign at 11pm")
- "landscape photography, coastal scenes" (not "rocky beach with driftwood log")
- "animal photography, wildlife closeup" (not "brown bear catching salmon")
- "wedding photography, ceremony moments" (not "bride walking down outdoor aisle")
- "event photography, live music" (not "guitarist on blue-lit stage")

The thematic tag should represent a photography style, setting type, mood, or subject category that multiple photos could share.`;
    return tagQuery;
  }
  case 'semantic': return 'List exactly 5 key elements or subjects in this image as a comma-separated list. Focus on concrete, visually distinct elements that define the scene. List them in order of visual prominence. Be specific but concise, using precise nouns without additional description.';
  }
};

const getAiImageQueryForField = (
  field: AiAutoGeneratedField,
  existingTitle?: string,
  existingTags?: Tags,
) => {
  switch(field) {
    case 'title': return `TITLE: ${getAiImageQuery('title', existingTitle, existingTags)}`;
    case 'caption': return `CAPTION: ${getAiImageQuery('caption', existingTitle, existingTags)}`;
    case 'tags': return `TAGS: ${getAiImageQuery('tags', existingTitle, existingTags)}`;
    case 'semantic': return `SEMANTIC: ${getAiImageQuery('semantic', existingTitle, existingTags)}`;
  }
};

export const getAiImageQuerySchema = (
  fields: AiAutoGeneratedField[],
  existingTitle?: string,
  existingTags?: Tags,
) => {
  const queryLines = [
    'Generate a set of meta content for the attached image:\n',
  ];

  fields.forEach(field => {
    queryLines.push(getAiImageQueryForField(field, existingTitle, existingTags));
  });

  const query = queryLines.join('\n');

  let schema = z.object();
  
  if (fields.includes('title')) {
    schema = schema.extend({ title: z.string() }); }
  if (fields.includes('caption')) {
    schema = schema.extend({ caption: z.string() }); }
  if (fields.includes('tags')) {
    schema = schema.extend({ tags: z.string() }); }
  if (fields.includes('semantic')) {
    schema = schema.extend({ semantic: z.string() }); }

  return {
    query,
    schema,
  };
};

export const parseTitleAndCaption = (text: string) => {
  const matches = text.includes('Title')
    ? text.match(/^[`'"]*Title: ["']*(.*?)["']*[ ]*Caption: ["']*(.*?)\.*["']*[`'"]*$/)
    : text.match(/^(.*?): (.*?)$/);

  return {
    title: matches?.[1] ?? '',
    caption: matches?.[2] ?? '',
  };
};

export const cleanUpAiTextResponse = (text: string) =>
  text
    .replaceAll('\n', ' ')
    .replaceAll('"', '')
    .replace(/\.$/, '');
